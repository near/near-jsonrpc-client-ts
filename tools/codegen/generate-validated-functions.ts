// Generate validated wrapper functions with individual schema imports
// This ensures optimal tree-shaking - only schemas for used functions are included

import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Generate schema name from type name
function typeToSchemaName(typeName: string): string {
  // Handle special cases
  if (typeName === 'GenesisConfig') return 'GenesisConfigSchema';
  if (typeName === 'GenesisConfigRequest') return 'RpcGenesisConfigRequestSchema';
  
  // Most types follow pattern: TypeName -> TypeNameSchema
  if (typeName.startsWith('Rpc')) {
    return typeName + 'Schema';
  }
  
  // Add Rpc prefix if not present
  return 'Rpc' + typeName + 'Schema';
}

interface MethodMapping {
  rpcMethod: string;
  clientMethodName: string;
  requestType: string;
  responseType: string;
}

function generateValidatedFunction(mapping: MethodMapping): string {
  const requestSchema = typeToSchemaName(mapping.requestType);
  const responseSchema = typeToSchemaName(mapping.responseType);
  
  return `
// ${mapping.rpcMethod} function with validation
export async function ${mapping.clientMethodName}(
  client: NearRpcClient,
  params?: ${mapping.requestType}
): Promise<${mapping.responseType}> {
  // Validate request parameters
  if (params) {
    ${requestSchema}().parse(params);
  }
  
  // Make request (without validation in client)
  const response = await client.makeRequest('${mapping.rpcMethod}', params);
  
  // Validate response structure
  const fullResponse = {
    jsonrpc: '2.0' as const,
    id: 'dontcare',
    result: response
  };
  ${responseSchema}().parse(fullResponse);
  
  return response;
}`;
}

export async function generateValidatedFunctions(
  mappings: MethodMapping[],
  outputPath: string
): Promise<void> {
  console.log('üîß Generating validated functions with individual schemas...');

  // Collect all unique types for imports
  const requestTypes = [...new Set(mappings.map(m => m.requestType))].sort();
  const responseTypes = [...new Set(mappings.map(m => m.responseType))].sort();
  const allTypes = [...new Set([...requestTypes, ...responseTypes])].sort();
  
  // Collect all schema names
  const schemaNames = [
    ...new Set([
      ...mappings.map(m => typeToSchemaName(m.requestType)),
      ...mappings.map(m => typeToSchemaName(m.responseType))
    ])
  ].sort();

  // Generate content
  const content = `// Auto-generated validated functions with individual schema imports
// Generated at: ${new Date().toISOString()}
// Total functions: ${mappings.length}
//
// This file is automatically generated by tools/codegen/generate-validated-functions.ts
// Do not edit manually - changes will be overwritten

import { NearRpcClient } from './client.js';
import type {
${allTypes.map(type => `  ${type},`).join('\n')}
} from '@near-js/jsonrpc-types';

// Import only the schemas we need for tree-shaking
import {
${schemaNames.map(schema => `  ${schema},`).join('\n')}
} from '@near-js/jsonrpc-types';

${mappings.map(generateValidatedFunction).join('\n')}
`;

  // Write the file
  await fs.writeFile(outputPath, content, 'utf8');
  
  console.log(`‚úÖ Generated validated functions at ${outputPath}`);
  console.log(`   Functions: ${mappings.length}`);
  console.log(`   Schemas imported: ${schemaNames.length}`);
}

// CLI entry point
if (import.meta.url === `file://${process.argv[1]}`) {
  async function main() {
    try {
      // Import mappings from the existing generated file
      const generatedPath = join(
        dirname(fileURLToPath(import.meta.url)),
        '../../packages/jsonrpc-client/src/generated-types.ts'
      );
      
      // Read the generated file to extract mappings
      const content = await fs.readFile(generatedPath, 'utf8');
      
      // Extract function definitions using regex
      const functionRegex = /export async function (\w+)\(\s*client: NearRpcClient,\s*params\?: (\w+)\s*\): Promise<(\w+)>/g;
      const mappings: MethodMapping[] = [];
      
      let match;
      while ((match = functionRegex.exec(content)) !== null) {
        const [, clientMethodName, requestType, responseType] = match;
        
        // Extract RPC method from the function body
        const functionBody = content.substring(match.index);
        const methodMatch = functionBody.match(/makeRequest\('([^']+)'/);
        
        if (methodMatch) {
          mappings.push({
            rpcMethod: methodMatch[1],
            clientMethodName,
            requestType,
            responseType,
          });
        }
      }
      
      // Output path
      const outputPath = join(
        dirname(fileURLToPath(import.meta.url)),
        '../../packages/jsonrpc-client/src/generated-validated-functions.ts'
      );
      
      await generateValidatedFunctions(mappings, outputPath);
      
      console.log('üéâ Validated functions generation complete!');
    } catch (error) {
      console.error('‚ùå Failed to generate validated functions:', error);
      process.exit(1);
    }
  }
  
  main();
}