// Generate validated wrapper functions with individual schema imports
// This ensures optimal tree-shaking - only schemas for used functions are included

import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Generate schema name from type name
function typeToSchemaName(typeName: string): string {
  // Handle special cases
  if (typeName === 'GenesisConfig') return 'GenesisConfigSchema';
  if (typeName === 'GenesisConfigRequest')
    return 'RpcGenesisConfigRequestSchema';

  // Most types follow pattern: TypeName -> TypeNameSchema
  if (typeName.startsWith('Rpc')) {
    return typeName + 'Schema';
  }

  // Add Rpc prefix if not present
  return 'Rpc' + typeName + 'Schema';
}

interface MethodMapping {
  rpcMethod: string;
  clientMethodName: string;
  requestType: string;
  responseType: string;
  paramsRequired: boolean;
}

function generateValidatedFunction(mapping: MethodMapping): string {
  const requestSchema = typeToSchemaName(mapping.requestType);
  const responseSchema = typeToSchemaName(mapping.responseType);

  // Use optional params only when the schema is nullable
  const paramsSignature = mapping.paramsRequired
    ? `params: ${mapping.requestType}`
    : `params?: ${mapping.requestType}`;

  // Validation logic depends on whether params are required
  const validationLogic = mapping.paramsRequired
    ? `  // Validate request parameters
  ${requestSchema}().parse(params);`
    : `  // Validate request parameters
  if (params) {
    ${requestSchema}().parse(params);
  }`;

  return `
// ${mapping.rpcMethod} function with validation
export async function ${mapping.clientMethodName}(
  client: NearRpcClient,
  ${paramsSignature}
): Promise<${mapping.responseType}> {
${validationLogic}
  
  // Make request (without validation in client)
  const response = await client.makeRequest('${mapping.rpcMethod}', params);
  
  // Validate response structure
  const fullResponse = {
    jsonrpc: '2.0' as const,
    id: 'dontcare',
    result: response
  };
  ${responseSchema}().parse(fullResponse);
  
  return response;
}`;
}

export async function generateValidatedFunctions(
  mappings: MethodMapping[],
  outputPath: string
): Promise<void> {
  console.log('üîß Generating validated functions with individual schemas...');

  // Collect all unique types for imports
  const requestTypes = [...new Set(mappings.map(m => m.requestType))].sort();
  const responseTypes = [...new Set(mappings.map(m => m.responseType))].sort();
  const allTypes = [...new Set([...requestTypes, ...responseTypes])].sort();

  // Collect all schema names
  const schemaNames = [
    ...new Set([
      ...mappings.map(m => typeToSchemaName(m.requestType)),
      ...mappings.map(m => typeToSchemaName(m.responseType)),
    ]),
  ].sort();

  // Generate content
  const content = `// Auto-generated validated functions with individual schema imports
// Generated at: ${new Date().toISOString()}
// Total functions: ${mappings.length}
//
// This file is automatically generated by tools/codegen/generate-validated-functions.ts
// Do not edit manually - changes will be overwritten

import { NearRpcClient } from './client.js';
import type {
${allTypes.map(type => `  ${type},`).join('\n')}
} from '@near-js/jsonrpc-types';

// Import only the schemas we need for tree-shaking
import {
${schemaNames.map(schema => `  ${schema},`).join('\n')}
} from '@near-js/jsonrpc-types';

${mappings.map(generateValidatedFunction).join('\n')}
`;

  // Write the file
  await fs.writeFile(outputPath, content, 'utf8');

  console.log(`‚úÖ Generated validated functions at ${outputPath}`);
  console.log(`   Functions: ${mappings.length}`);
  console.log(`   Schemas imported: ${schemaNames.length}`);
}

// CLI entry point
if (import.meta.url === `file://${process.argv[1]}`) {
  async function main() {
    try {
      // Import mappings from the existing generated file
      const generatedPath = join(
        dirname(fileURLToPath(import.meta.url)),
        '../../packages/jsonrpc-client/src/generated-types.ts'
      );

      // Read the generated file to extract mappings
      const content = await fs.readFile(generatedPath, 'utf8');

      // Extract function definitions using regex - handle both optional and required params
      const functionRegexOptional =
        /export async function (\w+)\(\s*client: NearRpcClient,\s*params\?\: (\w+)\s*\): Promise<(\w+)>/g;
      const functionRegexRequired =
        /export async function (\w+)\(\s*client: NearRpcClient,\s*params\: (\w+)\s*\): Promise<(\w+)>/g;
      const mappings: MethodMapping[] = [];

      // First find functions with optional params
      let match;
      while ((match = functionRegexOptional.exec(content)) !== null) {
        const [, clientMethodName, requestType, responseType] = match;

        // Extract RPC method from the function body
        const functionBody = content.substring(match.index);
        const methodMatch = functionBody.match(/makeRequest\('([^']+)'/);

        if (methodMatch) {
          mappings.push({
            rpcMethod: methodMatch[1],
            clientMethodName,
            requestType,
            responseType,
            paramsRequired: false,
          });
        }
      }

      // Then find functions with required params
      while ((match = functionRegexRequired.exec(content)) !== null) {
        const [, clientMethodName, requestType, responseType] = match;

        // Skip if already found as optional
        if (mappings.some(m => m.clientMethodName === clientMethodName))
          continue;

        // Extract RPC method from the function body
        const functionBody = content.substring(match.index);
        const methodMatch = functionBody.match(/makeRequest\('([^']+)'/);

        if (methodMatch) {
          mappings.push({
            rpcMethod: methodMatch[1],
            clientMethodName,
            requestType,
            responseType,
            paramsRequired: true,
          });
        }
      }

      // Output path
      const outputPath = join(
        dirname(fileURLToPath(import.meta.url)),
        '../../packages/jsonrpc-client/src/generated-validated-functions.ts'
      );

      await generateValidatedFunctions(mappings, outputPath);

      console.log('üéâ Validated functions generation complete!');
    } catch (error) {
      console.error('‚ùå Failed to generate validated functions:', error);
      process.exit(1);
    }
  }

  main();
}
