// Generate TypeScript interface for NEAR RPC client with proper types
// Part of the codegen toolchain

import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Types for the generation process
interface MethodMapping {
  rpcMethod: string;
  clientMethodName: string;
  requestType: string;
  responseType: string;
}

interface GeneratedInterface {
  content: string;
  methodCount: number;
  timestamp: string;
}

// Convert RPC method name to camelCase TypeScript method name
function rpcMethodToCamelCase(method: string): string {
  if (method.startsWith('EXPERIMENTAL_')) {
    const suffix = method.substring(13); // Remove 'EXPERIMENTAL_'
    return 'experimental' + suffix
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  } else {
    return method
      .split('_')
      .map((word, index) => 
        index === 0 
          ? word.toLowerCase() 
          : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
      )
      .join('');
  }
}

// Convert RPC method name to TypeScript type name
function rpcMethodToTypeName(method: string, suffix: 'Request' | 'Response'): string {
  if (method.startsWith('EXPERIMENTAL_')) {
    const baseName = method.substring(13); // Remove 'EXPERIMENTAL_'
    return `EXPERIMENTAL${baseName
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')}${suffix}`;
  } else {
    return `${method
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')}${suffix}`;
  }
}

// Generate method mappings from RPC_METHODS array
function generateMethodMappings(rpcMethods: readonly string[]): MethodMapping[] {
  return rpcMethods.map(rpcMethod => ({
    rpcMethod,
    clientMethodName: rpcMethodToCamelCase(rpcMethod),
    requestType: rpcMethodToTypeName(rpcMethod, 'Request'),
    responseType: rpcMethodToTypeName(rpcMethod, 'Response'),
  }));
}

// Generate the TypeScript interface with proper types
function generateInterfaceContent(mappings: MethodMapping[]): GeneratedInterface {
  const timestamp = new Date().toISOString();
  
  // Generate method signatures with proper types
  const methodSignatures = mappings.map(mapping => {
    return `  ${mapping.clientMethodName}(params?: ${mapping.requestType}): Promise<${mapping.responseType}>;`;
  });

  // Generate type imports
  const requestTypes = [...new Set(mappings.map(m => m.requestType))].sort();
  const responseTypes = [...new Set(mappings.map(m => m.responseType))].sort();
  // Add QueryResponse for convenience methods (use Set to avoid duplicates)
  const allTypes = [...new Set([...requestTypes, ...responseTypes, 'QueryResponse'])].sort();
  
  const importStatement = `import type {\n  ${allTypes.join(',\n  ')}\n} from '@near-js/jsonrpc-types';`;

  const content = `// Auto-generated TypeScript interface for NEAR RPC client
// Generated at: ${timestamp}
// Total methods: ${mappings.length}
// 
// This file is automatically generated by tools/codegen/generate-client-interface.ts
// Do not edit manually - changes will be overwritten

${importStatement}

// Dynamic RPC methods interface with proper typing
export interface DynamicRpcMethods {
${methodSignatures.join('\n')}
}

// Convenience methods interface
export interface ConvenienceMethods {
  viewAccount(params: {
    accountId: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }): Promise<QueryResponse>;
  
  viewFunction(params: {
    accountId: string;
    methodName: string;
    argsBase64?: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }): Promise<QueryResponse>;
  
  viewAccessKey(params: {
    accountId: string;
    publicKey: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }): Promise<QueryResponse>;
}

// Combined interface for the complete client
export interface CompleteClientInterface extends DynamicRpcMethods, ConvenienceMethods {
  // Generic call method for ultimate flexibility
  call<TParams = unknown, TResult = unknown>(
    method: string, 
    params?: TParams
  ): Promise<TResult>;
}
`;

  return {
    content,
    methodCount: mappings.length,
    timestamp,
  };
}

// Main generator function
export async function generateClientInterface(
  rpcMethods: readonly string[],
  outputPath: string
): Promise<GeneratedInterface> {
  console.log('üîß Generating TypeScript client interface...');
  
  // Generate method mappings
  const mappings = generateMethodMappings(rpcMethods);
  console.log(`   Found ${mappings.length} RPC methods to generate`);
  
  // Generate the interface
  const generated = generateInterfaceContent(mappings);
  
  // Ensure output directory exists
  await fs.mkdir(dirname(outputPath), { recursive: true });
  
  // Write the generated interface
  await fs.writeFile(outputPath, generated.content, 'utf8');
  
  console.log(`‚úÖ Generated client interface at ${outputPath}`);
  console.log(`   Methods: ${generated.methodCount}`);
  console.log(`   Timestamp: ${generated.timestamp}`);
  
  return generated;
}

// CLI entry point
if (import.meta.url === `file://${process.argv[1]}`) {
  async function main() {
    try {
      // Import RPC_METHODS from the types package
      const { RPC_METHODS } = await import('../../packages/jsonrpc-types/dist/index.mjs');
      
      // Output path - resolve relative to the project root, not codegen directory
      const projectRoot = join(dirname(fileURLToPath(import.meta.url)), '../..');
      const outputPath = join(projectRoot, 'packages/jsonrpc-client/src/generated-types.ts');
      
      await generateClientInterface(RPC_METHODS, outputPath);
      
      console.log('üéâ Client interface generation complete!');
    } catch (error) {
      console.error('‚ùå Failed to generate client interface:', error);
      process.exit(1);
    }
  }
  
  main();
}