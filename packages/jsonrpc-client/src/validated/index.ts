// Auto-generated validation wrapper functions
// Generated at: 2025-11-19T06:05:36.366Z
// Total functions: 31
//
// This file is automatically generated by tools/codegen/generate-validation-wrappers.ts
// Do not edit manually - changes will be overwritten

import type { NearRpcClient } from '../client.js';
import * as baseFunctions from '../generated-functions.js';
import type {
  AccessKeyView,
  AccountView,
  CallResult,
  CryptoHash,
  EXPERIMENTALMaintenanceWindowsResponse,
  EXPERIMENTALValidatorsOrderedResponse,
  GenesisConfig,
  GenesisConfigRequest,
  MaintenanceWindowsResponse,
  RpcBlockRequest,
  RpcBlockResponse,
  RpcChunkRequest,
  RpcChunkResponse,
  RpcClientConfigRequest,
  RpcClientConfigResponse,
  RpcCongestionLevelRequest,
  RpcCongestionLevelResponse,
  RpcGasPriceRequest,
  RpcGasPriceResponse,
  RpcHealthRequest,
  RpcHealthResponse,
  RpcLightClientBlockProofRequest,
  RpcLightClientBlockProofResponse,
  RpcLightClientExecutionProofRequest,
  RpcLightClientExecutionProofResponse,
  RpcLightClientNextBlockRequest,
  RpcLightClientNextBlockResponse,
  RpcMaintenanceWindowsRequest,
  RpcNetworkInfoRequest,
  RpcNetworkInfoResponse,
  RpcProtocolConfigRequest,
  RpcProtocolConfigResponse,
  RpcQueryRequest,
  RpcQueryResponse,
  RpcReceiptRequest,
  RpcReceiptResponse,
  RpcSendTransactionRequest,
  RpcSplitStorageInfoRequest,
  RpcSplitStorageInfoResponse,
  RpcStateChangesInBlockByTypeRequest,
  RpcStateChangesInBlockByTypeResponse,
  RpcStateChangesInBlockRequest,
  RpcStateChangesInBlockResponse,
  RpcStatusRequest,
  RpcStatusResponse,
  RpcTransactionResponse,
  RpcTransactionStatusRequest,
  RpcValidatorRequest,
  RpcValidatorResponse,
  RpcValidatorsOrderedRequest,
} from '@near-js/jsonrpc-types';
import {
  CryptoHashSchema,
  GenesisConfigRequestSchema,
  GenesisConfigSchema,
  RpcBlockRequestSchema,
  RpcBlockResponseSchema,
  RpcChunkRequestSchema,
  RpcChunkResponseSchema,
  RpcClientConfigRequestSchema,
  RpcClientConfigResponseSchema,
  RpcCongestionLevelRequestSchema,
  RpcCongestionLevelResponseSchema,
  RpcGasPriceRequestSchema,
  RpcGasPriceResponseSchema,
  RpcHealthRequestSchema,
  RpcHealthResponseSchema,
  RpcLightClientBlockProofRequestSchema,
  RpcLightClientBlockProofResponseSchema,
  RpcLightClientExecutionProofRequestSchema,
  RpcLightClientExecutionProofResponseSchema,
  RpcLightClientNextBlockRequestSchema,
  RpcLightClientNextBlockResponseSchema,
  RpcMaintenanceWindowsRequestSchema,
  RpcNetworkInfoRequestSchema,
  RpcNetworkInfoResponseSchema,
  RpcProtocolConfigRequestSchema,
  RpcProtocolConfigResponseSchema,
  RpcQueryRequestSchema,
  RpcQueryResponseSchema,
  RpcReceiptRequestSchema,
  RpcReceiptResponseSchema,
  RpcSendTransactionRequestSchema,
  RpcSplitStorageInfoRequestSchema,
  RpcSplitStorageInfoResponseSchema,
  RpcStateChangesInBlockByTypeRequestSchema,
  RpcStateChangesInBlockByTypeResponseSchema,
  RpcStateChangesInBlockRequestSchema,
  RpcStateChangesInBlockResponseSchema,
  RpcStatusRequestSchema,
  RpcStatusResponseSchema,
  RpcTransactionResponseSchema,
  RpcTransactionStatusRequestSchema,
  RpcValidatorRequestSchema,
  RpcValidatorResponseSchema,
  RpcValidatorsOrderedRequestSchema,
} from '@near-js/jsonrpc-types';

// Re-export non-validation convenience functions
export { parseCallResultToJson, viewFunctionAsJson } from '../convenience.js';

// Empty enableValidation function (validation is always enabled in these exports)
export function enableValidation(): void {
  // Intentionally empty - validation is always enabled for these exports
}

// Convenience function wrappers with validation
export async function viewAccount(
  client: NearRpcClient,
  params: {
    accountId: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<AccountView> {
  // Use the validated query function
  const queryParams = params.blockId
    ? {
        requestType: 'view_account' as const,
        accountId: params.accountId,
        blockId: params.blockId,
      }
    : {
        requestType: 'view_account' as const,
        accountId: params.accountId,
        finality: params.finality || ('final' as const),
      };

  return query(client, queryParams) as Promise<AccountView>;
}

export async function viewFunction(
  client: NearRpcClient,
  params: {
    accountId: string;
    methodName: string;
    argsBase64?: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<CallResult> {
  // Use the validated query function
  const baseParams = {
    requestType: 'call_function' as const,
    accountId: params.accountId,
    methodName: params.methodName,
    argsBase64: params.argsBase64 ?? '',
  };

  const queryParams = params.blockId
    ? { ...baseParams, blockId: params.blockId }
    : { ...baseParams, finality: params.finality || ('final' as const) };

  return query(client, queryParams) as Promise<CallResult>;
}

export async function viewAccessKey(
  client: NearRpcClient,
  params: {
    accountId: string;
    publicKey: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<AccessKeyView> {
  // Use the validated query function
  const queryParams = params.blockId
    ? {
        requestType: 'view_access_key' as const,
        accountId: params.accountId,
        publicKey: params.publicKey,
        blockId: params.blockId,
      }
    : {
        requestType: 'view_access_key' as const,
        accountId: params.accountId,
        publicKey: params.publicKey,
        finality: params.finality || ('final' as const),
      };

  return query(client, queryParams) as Promise<AccessKeyView>;
}

// Validation wrapper functions
/**
 * [Deprecated] Returns changes for a given account, contract or contract code
 * for given block height or hash. Consider using changes instead.
 */
export async function experimentalChanges(
  client: NearRpcClient,
  params: RpcStateChangesInBlockByTypeRequest
): Promise<RpcStateChangesInBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockByTypeRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalChanges(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * [Deprecated] Returns changes in block for given block height or hash over
 * all transactions for all the types. Includes changes like account_touched,
 * access_key_touched, data_touched, contract_code_touched. Consider using
 * block_effects instead
 */
export async function experimentalChangesInBlock(
  client: NearRpcClient,
  params: RpcStateChangesInBlockRequest
): Promise<RpcStateChangesInBlockByTypeResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalChangesInBlock(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockByTypeResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Queries the congestion level of a shard. More info about congestion
 * [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
 */
export async function experimentalCongestionLevel(
  client: NearRpcClient,
  params: RpcCongestionLevelRequest
): Promise<RpcCongestionLevelResponse> {
  // Validate request parameters
  const requestSchema = RpcCongestionLevelRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalCongestionLevel(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcCongestionLevelResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * [Deprecated] Get initial state and parameters for the genesis block.
 * Consider genesis_config instead.
 */
export async function experimentalGenesisConfig(
  client: NearRpcClient,
  params?: GenesisConfigRequest
): Promise<GenesisConfig> {
  // Validate request parameters
  const requestSchema = GenesisConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalGenesisConfig(client, params);

  // Validate response
  const responseSchema = GenesisConfigSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Returns the proofs for a transaction execution. */
export async function experimentalLightClientBlockProof(
  client: NearRpcClient,
  params: RpcLightClientBlockProofRequest
): Promise<RpcLightClientBlockProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientBlockProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalLightClientBlockProof(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcLightClientBlockProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Returns the proofs for a transaction execution. */
export async function experimentalLightClientProof(
  client: NearRpcClient,
  params: RpcLightClientExecutionProofRequest
): Promise<RpcLightClientExecutionProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientExecutionProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalLightClientProof(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcLightClientExecutionProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * [Deprecated] Returns the future windows for maintenance in current epoch
 * for the specified account. In the maintenance windows, the node will not be
 * block producer or chunk producer. Consider using maintenance_windows
 * instead.
 */
export async function experimentalMaintenanceWindows(
  client: NearRpcClient,
  params: RpcMaintenanceWindowsRequest
): Promise<EXPERIMENTALMaintenanceWindowsResponse> {
  // Validate request parameters
  const requestSchema = RpcMaintenanceWindowsRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function (no response validation needed)
  return baseFunctions.experimentalMaintenanceWindows(client, params);
}

/**
 * A configuration that defines the protocol-level parameters such as
 * gas/storage costs, limits, feature flags, other settings
 */
export async function experimentalProtocolConfig(
  client: NearRpcClient,
  params: RpcProtocolConfigRequest
): Promise<RpcProtocolConfigResponse> {
  // Validate request parameters
  const requestSchema = RpcProtocolConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalProtocolConfig(client, params);

  // Validate response
  const responseSchema = RpcProtocolConfigResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Fetches a receipt by its ID (as is, without a status or execution outcome) */
export async function experimentalReceipt(
  client: NearRpcClient,
  params: RpcReceiptRequest
): Promise<RpcReceiptResponse> {
  // Validate request parameters
  const requestSchema = RpcReceiptRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalReceipt(client, params);

  // Validate response
  const responseSchema = RpcReceiptResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Contains the split storage information. More info on split storage
 * [here](https://near-nodes.io/archival/split-storage-archival)
 */
export async function experimentalSplitStorageInfo(
  client: NearRpcClient,
  params: RpcSplitStorageInfoRequest
): Promise<RpcSplitStorageInfoResponse> {
  // Validate request parameters
  const requestSchema = RpcSplitStorageInfoRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalSplitStorageInfo(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcSplitStorageInfoResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Queries status of a transaction by hash, returning the final transaction
 * result and details of all receipts.
 */
export async function experimentalTxStatus(
  client: NearRpcClient,
  params: RpcTransactionStatusRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcTransactionStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalTxStatus(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns the current epoch validators ordered in the block producer order
 * with repetition. This endpoint is solely used for bridge currently and is
 * not intended for other external use cases.
 */
export async function experimentalValidatorsOrdered(
  client: NearRpcClient,
  params: RpcValidatorsOrderedRequest
): Promise<EXPERIMENTALValidatorsOrderedResponse> {
  // Validate request parameters
  const requestSchema = RpcValidatorsOrderedRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function (no response validation needed)
  return baseFunctions.experimentalValidatorsOrdered(client, params);
}

/** Returns block details for given height or hash */
export async function block(
  client: NearRpcClient,
  params: RpcBlockRequest
): Promise<RpcBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.block(client, params);

  // Validate response
  const responseSchema = RpcBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns changes in block for given block height or hash over all
 * transactions for all the types. Includes changes like account_touched,
 * access_key_touched, data_touched, contract_code_touched.
 */
export async function blockEffects(
  client: NearRpcClient,
  params: RpcStateChangesInBlockRequest
): Promise<RpcStateChangesInBlockByTypeResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.blockEffects(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockByTypeResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * [Deprecated] Sends a transaction and immediately returns transaction hash.
 * Consider using send_tx instead.
 */
export async function broadcastTxAsync(
  client: NearRpcClient,
  params: RpcSendTransactionRequest
): Promise<CryptoHash> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.broadcastTxAsync(client, params);

  // Validate response
  const responseSchema = CryptoHashSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * [Deprecated] Sends a transaction and waits until transaction is fully
 * complete. (Has a 10 second timeout). Consider using send_tx instead.
 */
export async function broadcastTxCommit(
  client: NearRpcClient,
  params: RpcSendTransactionRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.broadcastTxCommit(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns changes for a given account, contract or contract code for given
 * block height or hash.
 */
export async function changes(
  client: NearRpcClient,
  params: RpcStateChangesInBlockByTypeRequest
): Promise<RpcStateChangesInBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockByTypeRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.changes(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns details of a specific chunk. You can run a block details query to
 * get a valid chunk hash.
 */
export async function chunk(
  client: NearRpcClient,
  params: RpcChunkRequest
): Promise<RpcChunkResponse> {
  // Validate request parameters
  const requestSchema = RpcChunkRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.chunk(client, params);

  // Validate response
  const responseSchema = RpcChunkResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Queries client node configuration */
export async function clientConfig(
  client: NearRpcClient,
  params?: RpcClientConfigRequest
): Promise<RpcClientConfigResponse> {
  // Validate request parameters
  const requestSchema = RpcClientConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.clientConfig(client, params);

  // Validate response
  const responseSchema = RpcClientConfigResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns gas price for a specific block_height or block_hash. Using [null]
 * will return the most recent block's gas price.
 */
export async function gasPrice(
  client: NearRpcClient,
  params: RpcGasPriceRequest
): Promise<RpcGasPriceResponse> {
  // Validate request parameters
  const requestSchema = RpcGasPriceRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.gasPrice(client, params);

  // Validate response
  const responseSchema = RpcGasPriceResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Get initial state and parameters for the genesis block */
export async function genesisConfig(
  client: NearRpcClient,
  params?: GenesisConfigRequest
): Promise<GenesisConfig> {
  // Validate request parameters
  const requestSchema = GenesisConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.genesisConfig(client, params);

  // Validate response
  const responseSchema = GenesisConfigSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Returns the current health status of the RPC node the client connects to. */
export async function health(
  client: NearRpcClient,
  params?: RpcHealthRequest
): Promise<RpcHealthResponse> {
  // Validate request parameters
  const requestSchema = RpcHealthRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.health(client, params);

  // Validate response
  const responseSchema = RpcHealthResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Returns the proofs for a transaction execution. */
export async function lightClientProof(
  client: NearRpcClient,
  params: RpcLightClientExecutionProofRequest
): Promise<RpcLightClientExecutionProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientExecutionProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.lightClientProof(client, params);

  // Validate response
  const responseSchema = RpcLightClientExecutionProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Returns the future windows for maintenance in current epoch for the
 * specified account. In the maintenance windows, the node will not be block
 * producer or chunk producer.
 */
export async function maintenanceWindows(
  client: NearRpcClient,
  params: RpcMaintenanceWindowsRequest
): Promise<MaintenanceWindowsResponse> {
  // Validate request parameters
  const requestSchema = RpcMaintenanceWindowsRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function (no response validation needed)
  return baseFunctions.maintenanceWindows(client, params);
}

/**
 * Queries the current state of node network connections. This includes
 * information about active peers, transmitted data, known producers, etc.
 */
export async function networkInfo(
  client: NearRpcClient,
  params?: RpcNetworkInfoRequest
): Promise<RpcNetworkInfoResponse> {
  // Validate request parameters
  const requestSchema = RpcNetworkInfoRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.networkInfo(client, params);

  // Validate response
  const responseSchema = RpcNetworkInfoResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/** Returns the next light client block. */
export async function nextLightClientBlock(
  client: NearRpcClient,
  params: RpcLightClientNextBlockRequest
): Promise<RpcLightClientNextBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientNextBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.nextLightClientBlock(client, params);

  // Validate response
  const responseSchema = RpcLightClientNextBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * This module allows you to make generic requests to the network. The
 * `RpcQueryRequest` struct takes in a
 * [`BlockReference`](https://docs.rs/near-primitives/0.12.0/near_primitives/types/enum.BlockReference.html)
 * and a
 * [`QueryRequest`](https://docs.rs/near-primitives/0.12.0/near_primitives/views/enum.QueryRequest.html).
 * The `BlockReference` enum allows you to specify a block by `Finality`,
 * `BlockId` or `SyncCheckpoint`. The `QueryRequest` enum provides multiple
 * variants for performing the following actions: - View an account's details
 * - View a contract's code - View the state of an account - View the
 * `AccessKey` of an account - View the `AccessKeyList` of an account - Call a
 * function in a contract deployed on the network.
 */
export async function query(
  client: NearRpcClient,
  params: RpcQueryRequest
): Promise<RpcQueryResponse> {
  // Validate request parameters
  const requestSchema = RpcQueryRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.query(client, params);

  // Validate response
  const responseSchema = RpcQueryResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Sends transaction. Returns the guaranteed execution status and the results
 * the blockchain can provide at the moment.
 */
export async function sendTx(
  client: NearRpcClient,
  params: RpcSendTransactionRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.sendTx(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Requests the status of the connected RPC node. This includes information
 * about sync status, nearcore node version, protocol version, the current set
 * of validators, etc.
 */
export async function status(
  client: NearRpcClient,
  params?: RpcStatusRequest
): Promise<RpcStatusResponse> {
  // Validate request parameters
  const requestSchema = RpcStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.status(client, params);

  // Validate response
  const responseSchema = RpcStatusResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Queries status of a transaction by hash and returns the final transaction
 * result.
 */
export async function tx(
  client: NearRpcClient,
  params: RpcTransactionStatusRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcTransactionStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.tx(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

/**
 * Queries active validators on the network. Returns details and the state of
 * validation on the blockchain.
 */
export async function validators(
  client: NearRpcClient,
  params: RpcValidatorRequest
): Promise<RpcValidatorResponse> {
  // Validate request parameters
  const requestSchema = RpcValidatorRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.validators(client, params);

  // Validate response
  const responseSchema = RpcValidatorResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}
